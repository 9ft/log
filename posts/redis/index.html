<!doctype html><html lang=zh-cn><head><title>Redis 学习笔记 ::
未命名</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="数据结构和对象 数据结构 源码位置 SDS sds.h LinkList adlist.h Dict dict.h Simple Dynamic Strings 文档: Hacking Strings sds.h typedef char *sds; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; // 字符串长度 uint8_t alloc; // 字符串最大容量 unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; sds 是指向一个 C 字符串的指针, 访问 Header 需要向前寻址 struct __attribute__ ((__packed__)) 表示不要内存对齐, 使用紧凑模式 char buf[] 是柔性数组, 在结构体的最后, 此前需要至少一个成员, 其"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=/posts/redis/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon.png><link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Redis 学习笔记"><meta name=twitter:description content="数据结构和对象 数据结构 源码位置 SDS sds.h LinkList adlist.h Dict dict.h Simple Dynamic Strings 文档: Hacking Strings sds.h typedef char *sds; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; // 字符串长度 uint8_t alloc; // 字符串最大容量 unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; sds 是指向一个 C 字符串的指针, 访问 Header 需要向前寻址 struct __attribute__ ((__packed__)) 表示不要内存对齐, 使用紧凑模式 char buf[] 是柔性数组, 在结构体的最后, 此前需要至少一个成员, 其"><meta property="og:title" content="Redis 学习笔记"><meta property="og:description" content="数据结构和对象 数据结构 源码位置 SDS sds.h LinkList adlist.h Dict dict.h Simple Dynamic Strings 文档: Hacking Strings sds.h typedef char *sds; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; // 字符串长度 uint8_t alloc; // 字符串最大容量 unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; sds 是指向一个 C 字符串的指针, 访问 Header 需要向前寻址 struct __attribute__ ((__packed__)) 表示不要内存对齐, 使用紧凑模式 char buf[] 是柔性数组, 在结构体的最后, 此前需要至少一个成员, 其"><meta property="og:type" content="article"><meta property="og:url" content="/posts/redis/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-06T00:30:00+08:00"><meta property="article:modified_time" content="2021-06-06T00:53:39+08:00"><meta property="og:site_name" content="未命名"><style type=text/css>body{font-weight:400}.logo__cursor{width:2px;background:#00ff7f}</style></head><body><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>未命名</span>
<span class=logo__cursor></span></a><span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/archive/>Archive</a></li><li><a href=/about>About</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/archive/>Archive</a></li><li><a href=/about>About</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>Redis 学习笔记</h1><div class=post-meta><span class=post-date>2021-06-06</span></div><div class=post-content><h2>Table of Contents</h2><aside class=table-of-contents><nav id=TableOfContents><ul><li><a href=#数据结构和对象>数据结构和对象</a><ul><li><a href=#simple-dynamic-strings>Simple Dynamic Strings</a></li><li><a href=#linklist>LinkList</a></li><li><a href=#dict>Dict</a></li></ul></li></ul></nav></aside><h2 id=数据结构和对象>数据结构和对象</h2><table><thead><tr><th>数据结构</th><th>源码位置</th></tr></thead><tbody><tr><td>SDS</td><td>sds.h</td></tr><tr><td>LinkList</td><td>adlist.h</td></tr><tr><td>Dict</td><td>dict.h</td></tr></tbody></table><h3 id=simple-dynamic-strings>Simple Dynamic Strings</h3><p><strong>文档</strong>: <a href=https://redis.io/topics/internals-sds>Hacking Strings</a></p><p><a href=https://github.com/redis/redis/blob/156599ba2db1706cd5ce10f1c335f36c3ccb94ea/src/sds.h#L51><code>sds.h</code></a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>sds;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>__attribute__</span> ((__packed__)) sdshdr8 {
    uint8_t len;         <span style=color:#75715e>// 字符串长度
</span><span style=color:#75715e></span>    uint8_t alloc;       <span style=color:#75715e>// 字符串最大容量
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> flags; <span style=color:#75715e>/* 3 lsb of type, 5 unused bits */</span>
    <span style=color:#66d9ef>char</span> buf[];
};
</code></pre></div><ul><li><p>sds 是指向一个 C 字符串的指针, 访问 Header 需要向前寻址</p></li><li><p><code>struct __attribute__ ((__packed__))</code> 表示不要内存对齐, 使用紧凑模式</p></li><li><p><code>char buf[]</code> 是柔性数组, 在结构体的最后, 此前需要至少一个成员, 其大小不计入结构体</p></li><li><p>不同长度字符串可以使用不同大小的 Header 从而节省内存, 如 sdshdr8 使用 uint8_t 表示长度.</p></li><li><p><code>flag</code> 前 3 个 bit 表示类型, 后 5 bit 未用. Header 与 buf 内存连续, flags 字段可以使用 sds[-1] 访问. 如
<a href=https://github.com/redis/redis/blob/156599ba2db1706cd5ce10f1c335f36c3ccb94ea/src/sds.h#L87>sds.h</a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> size_t <span style=color:#a6e22e>sdslen</span>(<span style=color:#66d9ef>const</span> sds s) {
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> flags <span style=color:#f92672>=</span> s[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>];
    <span style=color:#66d9ef>switch</span>(flags<span style=color:#f92672>&amp;</span>SDS_TYPE_MASK) {
        <span style=color:#66d9ef>case</span> SDS_TYPE_5:
            <span style=color:#66d9ef>return</span> SDS_TYPE_5_LEN(flags);
        <span style=color:#66d9ef>case</span> SDS_TYPE_8:
            <span style=color:#66d9ef>return</span> SDS_HDR(<span style=color:#ae81ff>8</span>,s)<span style=color:#f92672>-&gt;</span>len;
        <span style=color:#66d9ef>case</span> SDS_TYPE_16:
            <span style=color:#66d9ef>return</span> SDS_HDR(<span style=color:#ae81ff>16</span>,s)<span style=color:#f92672>-&gt;</span>len;
        <span style=color:#66d9ef>case</span> SDS_TYPE_32:
            <span style=color:#66d9ef>return</span> SDS_HDR(<span style=color:#ae81ff>32</span>,s)<span style=color:#f92672>-&gt;</span>len;
        <span style=color:#66d9ef>case</span> SDS_TYPE_64:
            <span style=color:#66d9ef>return</span> SDS_HDR(<span style=color:#ae81ff>64</span>,s)<span style=color:#f92672>-&gt;</span>len;
    }
    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
}
</code></pre></div></li></ul><p><strong>结论</strong></p><p>与原生 C 字符串相比:</p><ol><li>保存了长度</li><li>API 安全, 不会造成缓冲区溢出</li><li>修改字符串长度 N 次最多执行 N 次内存分配 (C 字符串一定为 N 次)</li><li>二进制安全, 可以保存二进制数据 (C字符串会用<code>\0</code>分割)</li><li>可以复用一部分&lt;string.h>库函数</li></ol><h3 id=linklist>LinkList</h3><p><a href=https://github.com/redis/redis/blob/156599ba2db1706cd5ce10f1c335f36c3ccb94ea/src/adlist.h#L36><code>adlist.h</code></a></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> listNode {
    <span style=color:#66d9ef>struct</span> listNode <span style=color:#f92672>*</span>prev;
    <span style=color:#66d9ef>struct</span> listNode <span style=color:#f92672>*</span>next;
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>value;
} listNode;

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> listIter {
    listNode <span style=color:#f92672>*</span>next;
    <span style=color:#66d9ef>int</span> direction;
} listIter;

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> list {
    listNode <span style=color:#f92672>*</span>head;
    listNode <span style=color:#f92672>*</span>tail;
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span>dup)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
    <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>free)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr);
    <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>match)(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr, <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key);
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> len;
} list;
</code></pre></div><p>实现为双端链表</p><h3 id=dict>Dict</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> dictEntry {
    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>key;  <span style=color:#75715e>// 值可以为指针
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>union</span> {
        <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>val;
        uint64_t u64;
        int64_t s64;
        <span style=color:#66d9ef>double</span> d;
    } v;
    <span style=color:#66d9ef>struct</span> dictEntry <span style=color:#f92672>*</span>next;  <span style=color:#75715e>// 使用链地址法解决冲突, 新节点会添加到表头
</span><span style=color:#75715e></span>} dictEntry;

<span style=color:#75715e>/* This is our hash table structure. Every dictionary has two of this as we
</span><span style=color:#75715e> * implement incremental rehashing, for the old to the new table. */</span>
<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> dictht {
    dictEntry <span style=color:#f92672>**</span>table;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> size;
    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> sizemask;  <span style=color:#75715e>// mask for calc hash, always equal size-1, 使用hash值和mask计算索引index = hash &amp; dict-&gt;ht[x].sizemask;
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> used;
} dictht;

<span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> dict {
    dictType <span style=color:#f92672>*</span>type;  <span style=color:#75715e>// hashFunction(key)定义在此(dict-&gt;type-&gt;hashFunction(key))
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>privdata;
    dictht ht[<span style=color:#ae81ff>2</span>];  <span style=color:#75715e>// ht[1]只会用于rehash
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>long</span> rehashidx; <span style=color:#75715e>// 当前rehash进度，-1为未在rehash
</span><span style=color:#75715e></span>    int16_t pauserehash; <span style=color:#75715e>/* If &gt;0 rehashing is paused (&lt;0 indicates coding error) */</span>
} dict;
</code></pre></div><p><img src=rehashing.png alt=rehashing></p><p><strong>hash方法</strong></p><p>当字典被用作数据库的底层实现, 或者哈希键的底层实现时, Redis 使用 MurmurHash2 算法来计算键的哈希值.</p><blockquote><p>MurmurHash算法最初由Austin Appleby于2008年发明, 这种算法的优点在于, 即使输入的键是有规律的, 算法仍能给出一个很好的随机分布性, 并且算法的计算速度也非常快.</p></blockquote><p><strong>rehash</strong></p><p>负载因子 (load factor) 要维持合理的范围内</p><p><code>load_factor = ht[0].used / ht[0].size</code></p><p><strong>扩展条件</strong>:</p><ul><li>未执行 BGSAVE 或 BGREWRITEAOF 命令, 且 load_factor >= 1</li><li>正执行 BGSAVE 或 BGREWRITEAOF 命令, 且 load_factor >= 5</li></ul><p>扩展为: 第一个大于等于 <code>ht[0].used*2</code> 的 <code>2^n</code></p><blockquote><p>在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中, Redis 需要创建当前服务器进程的子进程, 而大多数操作系统都采用写时复制 (copy-on-write) 技术来优化子进程的使用效率, 所以在子进程存在期间, 服务器会提高执行扩展操作所需的负载因子, 从而尽可能地避免在子进程存在期间进行哈希表扩展操作, 这可以避免不必要的内存写入操作, 最大限度地节约内存.</p></blockquote><p><strong>收缩条件</strong>:</p><ul><li><code>load_factor &lt; 0.1</code></li></ul><p>收缩为: 第一个大于等于 <code>ht[0].used</code> 的 <code>2^n</code></p><p><strong>渐进式</strong></p><p>避免对服务器性能造成影响, rehash 为多次, 渐进式完成的</p><ol><li>为 ht[1] 分配空间, 让字典同时持有 ht[0] ht[1]</li><li>将数据从 ht[0] rehash 到 ht[1], rehashidx 记录进度, 完成时置为-1</li></ol><p><strong>rehash期间</strong></p><ul><li>delete/find/update 操作时字典会同时使用 ht[0] 和 ht[1] 两个哈希表</li><li>insert操作只会使用 ht[1] 表, 确保 ht[0] 只增不减</li></ul></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>更多</span><hr></div><div class=pagination__buttons><span class="button next"><a href=/posts/k8s-on-raspberry/><span class=button__text>使用树莓派搭建K8s集群</span>
<span class=button__icon>→</span></a></span></div></div><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//mindytech.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>未命名</span>
<span class=logo__cursor></span></a><div class=copyright><span>© 2021 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script src=/assets/main.js></script><script src=/assets/prism.js></script></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-46567212-1','auto'),ga('send','pageview'))</script></body></html>